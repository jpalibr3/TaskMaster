Okay, I've reviewed your app.py and README.md files. It's a solid foundation for a Salesforce AI assistant with a web interface, and the NLU pre-processing with SOQL generation is a good strategy for more precise queries!

Here's a breakdown of my review and suggestions for enhancements, particularly focusing on making it easier for non-Salesforce users and improving robustness:

Key Observation & Critical Refinement for SOQL Strategy:

There seems to be a logical disconnect in how the SOQL query generated by get_optimized_zapier_input is utilized by the call_zapier_mcp function:

get_optimized_zapier_input: This function correctly generates a SOQL query based on the user's input and then crafts an instruction string like: "Use Salesforce: Find Record(s) by Query with the SOQL query: '[GENERATED_SOQL_STRING]'"
call_zapier_mcp: This function receives the above string as action. However, its current logic (with select_tool, prepare_tool_arguments, and extract_search_parameters) then tries to re-parse this action string as natural language to determine the object, search field, value, and operator. This effectively ignores the already generated SOQL query. The extract_search_parameters function is not designed to pull a SOQL query out of that instruction string.
Suggestion 1: Refactor call_zapier_mcp to correctly use the SOQL query

The call_zapier_mcp function needs to identify when the action string contains a SOQL query and then directly use that query with the appropriate Zapier tool (e.g., "Salesforce: Find Record(s) by Query").

Here's a suggested modification for app.py's SalesforceWebAssistant.call_zapier_mcp method:

Python

import re # Add this import at the top of your app.py
import time # Add this import

# ... (inside SalesforceWebAssistant class)

    def call_zapier_mcp(self, action: str) -> Dict[str, Any]:
        """Make request to Zapier MCP server, prioritizing SOQL if provided."""
        try:
            headers = {
                "Authorization": f"Bearer {self.zapier_mcp_api_key}",
                "Content-Type": "application/json",
                "Accept": "application/json, text/event-stream"
            }

            call_payload = None
            tool_name_for_logging = "unknown"

            # Check if the action is a pre-formatted SOQL command
            soql_match = re.search(r"Use Salesforce: Find Record\(s\) by Query with the SOQL query:\s*'(.*)'", action)

            if soql_match:
                soql_query = soql_match.group(1)
                tool_name_for_logging = "Salesforce: Find Record(s) by Query"
                call_payload = {
                    "jsonrpc": "2.0",
                    "id": "soql_call_" + str(int(time.time())),
                    "method": "tools/call",
                    "params": {
                        "name": tool_name_for_logging,
                        "arguments": {
                            "query": soql_query
                            # Zapier's "Find Record(s) by Query" tool typically expects 'query' as the argument key.
                            # If it expects "instructions" containing the SOQL, adjust as needed.
                        }
                    }
                }
                logger.info(f"Calling Zapier with SOQL: Tool='{tool_name_for_logging}', Query='{soql_query}'")
            else:
                # Fallback to original behavior for non-SOQL commands (e.g., create, update)
                # This path needs robust tool selection and argument preparation for those actions.
                logger.info(f"Action '{action}' is not a SOQL command, using general tool selection.")
                
                tools_payload_list = { "jsonrpc": "2.0", "id": "list_tools_" + str(int(time.time())), "method": "tools/list" }
                tools_response = requests.post(self.zapier_mcp_url, headers=headers, json=tools_payload_list, timeout=30)
                if tools_response.status_code != 200:
                     return {"success": False, "error": f"Failed to get tools: {tools_response.status_code} - {tools_response.text}"}

                events_list = self.parse_sse_response(tools_response.text)
                available_tools_data = []
                for event in events_list:
                    if event.get('type') == 'message' and isinstance(event.get('data'), dict):
                        event_data = event['data']
                        if 'result' in event_data and 'tools' in event_data['result']:
                            available_tools_data = event_data['result']['tools']
                            break
                if not available_tools_data:
                     return {"success": False, "error": "No tools available from Zapier MCP"}

                selected_tool = self.select_tool(action, available_tools_data)
                if not selected_tool:
                     return {"success": False, "error": "No suitable Zapier tool found for this action."}
                
                tool_name_for_logging = selected_tool['name']
                # For non-SOQL 'find' actions, prepare_tool_arguments would still use extract_search_parameters.
                # For 'create', 'update' actions, prepare_tool_arguments would need to be enhanced
                # to extract relevant fields and values for those operations.
                tool_args = self.prepare_tool_arguments(action, selected_tool)

                call_payload = {
                    "jsonrpc": "2.0",
                    "id": "non_soql_call_" + str(int(time.time())),
                    "method": "tools/call",
                    "params": {
                        "name": tool_name_for_logging,
                        "arguments": tool_args
                    }
                }
                logger.info(f"Calling Zapier with non-SOQL: Tool='{tool_name_for_logging}', Args='{tool_args}'")

            if not call_payload: # Should not happen if logic is correct
                return {"success": False, "error": "Internal error: Could not determine call payload."}

            call_response = requests.post(self.zapier_mcp_url, headers=headers, json=call_payload, timeout=60)

            if call_response.status_code == 200:
                call_events = self.parse_sse_response(call_response.text)
                for event in call_events:
                    if event.get('type') == 'message' and isinstance(event.get('data'), dict):
                        event_data = event['data']
                        if 'result' in event_data:
                            result_content = event_data['result']
                            # Handle Zapier follow-up questions
                            if isinstance(result_content, dict) and 'content' in result_content:
                                content_list = result_content['content']
                                if isinstance(content_list, list) and len(content_list) > 0:
                                    first_content_item = content_list[0]
                                    if isinstance(first_content_item, dict) and 'text' in first_content_item:
                                        text_data = first_content_item['text']
                                        try:
                                            parsed_text_data = json.loads(text_data)
                                            if isinstance(parsed_text_data, dict) and parsed_text_data.get('followUpQuestion'):
                                                logger.warning(f"Zapier follow-up: {parsed_text_data['followUpQuestion']}")
                                                return {
                                                    "success": False,
                                                    "error": f"Zapier needs more information: {parsed_text_data['followUpQuestion']}",
                                                    "type": "clarification_needed_zapier" # Frontend can handle this type
                                                }
                                        except json.JSONDecodeError:
                                            pass # Not a JSON follow-up
                            return {"success": True, "data": result_content, "tool_used": tool_name_for_logging}
                
                logger.warning("Zapier call 200 OK but no 'result' in message events.")
                return {"success": True, "data": call_events, "tool_used": tool_name_for_logging, "message": "Request processed, but no specific data result."}
            else:
                error_message = f"Tool call failed: {call_response.status_code} - {call_response.text}"
                try:
                    error_data = call_response.json()
                    if error_data and 'error' in error_data and 'message' in error_data['error']:
                        error_message = f"Zapier Error: {error_data['error']['message']}"
                except json.JSONDecodeError:
                    pass
                logger.error(error_message)
                return {"success": False, "error": error_message}

        except requests.exceptions.Timeout:
            logger.error("Zapier MCP request timed out")
            return {"success": False, "error": "The request to Salesforce (via Zapier) timed out. Please try again."}
        except requests.exceptions.RequestException as e:
            logger.error(f"Zapier MCP request error: {e}")
            return {"success": False, "error": f"A connection error occurred with Salesforce (via Zapier): {str(e)}"}
        except Exception as e:
            logger.error(f"Unexpected error calling Zapier MCP: {e}", exc_info=True)
            return {"success": False, "error": f"An unexpected error occurred: {str(e)}"}

You'll also want to handle the clarification_needed_zapier type in your /api/send_command route in app.py, similar to how nlu_error or clarification_needed are handled.